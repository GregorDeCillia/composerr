
# composerr

<!-- badges: start -->

[![GitHub last
commit](https://img.shields.io/github/last-commit/a-maldet/composerr.svg?logo=github)](https://github.com/a-maldet/composerr/commits/master)
[![GitHub code size in
bytes](https://img.shields.io/github/languages/code-size/a-maldet/composerr.svg?logo=github)](https://github.com/a-maldet/composerr)
<!-- badges: end -->

This **R package** makes it easy to add a **full range and maintainable
error handling** to your functions and packages, without inflating your
code.

> Make error handling in R less tedious

## Installation

``` r
# Install development version from GitHub
devtools::install_github('a-maldet/composerr', build_opts = NULL)
```

## Usage

``` r
library(composerr)
```

### List of available functions

  - `composerr()`: Create new error handling function from scratch.
  - `composerr(err_h = err_h)`: Create new error handling function from
    the previously created error handler `err_h()`.
  - `composerr_modify(err_h)`: Modify the existing error handling
    function `err_h` without creating a new one.
  - `composerr_halt(err_h)`: Halt error processing and accumulate all
    error messages generated by calling `err_h()` in an error stack.
  - `composerr_flush(err_h)`: Flush entire error stack, holding all
    stacked error messages generated by calling `err_h`.
  - `composerr_counterr(err_h)`: Number of accumulated error messages
    generated by calling `err_h()`.
  - `composerr_get_internal_handler(err_h)`: Retrieve the internal error
    processing function of `err_h`.
  - `validate_composerr(err_h)`: Validate that `err_h` is indeed an
    error handler created by `composerr()`.

### Creating error handlers from scratch

The call

``` r
err_h1 <- composerr(text_1 = "A problem appeared", sep_1 = ": ")
```

creates a `composerr` class object `err_h1`, which is basically a
function `err_h1 = function(msg, ...)`. Calling `err_h1(msg)` will throw
an error with a meaningful error message:

``` r
err_h1("The fridge is empty.")
# Error: A problem appeared: The fridge is empty.
```

As one can see, the error message `"The fridge is empty."` is
concatenated to the message parts defined in `text_1` and `sep_1`. In
total the resulting error message is constructed as follows:

``` r
text_1 + sep_1 + msg + sep_2 + text_2
```

### Creating a child error handlers

Sometimes it is useful, to create an error handler `err_h_child` from
another error handler `err_h1`. In this case `err_h1_child` is called a
**child** of `err_h1` and `err_h1` is its **parent**.

``` r
err_h_dinner <- composerr("Problem with dinner")
err_h_dinner_missing <- composerr(
  text_2 = "is missing.",
  sep_2 = " ",
  err_h = err_h_dinner
)

err_h_dinner_missing("Wine")
# Error: Problem with dinner: Wine is missing

err_h_dinner_missing("Food")
# Error: Problem with dinner: Food is missing

err_h_dinner("Guests are late.")
# Error: Problem with dinner: Guests are late.
```

Sometimes, one may even create an error handler from an error handler,
which was itself created from another error handler and so on. Let us
assume that `err_h10` was created from `err_h9` and `err_h9` was again
created from `err_h8` and so on, down to `err_h1`. If you call
`err_h10(msg)`, then the resulting error message is created as follows:

``` r
text_1_h1 + sep_1_h1 + ... + text_1_h10 + sep_1_h10 +
  msg +
  sep_2_h10 + text_2_h10 + ... + sep_2_h1 + text_2_h1
```

### Change behavior of error handler

If we have an error handler `err_h1`, then the final error message
processing has a large variety of possibilities:

  - throw an error with the created message text (`stop(msg)`)
  - print a warning with the created message text (`warning(msg)`)
  - print the created message text as normal text to the console
    (`cat(msg)`)
  - write the created message text to a log file (`cat(msg, file = FILE,
    append = TRUE, fill = TRUE)`)

The final error message processing mechanism of an error handler
`err_h1` can be defined by setting `internal_handler`. There are three
possibilities:

  - `internal_handler` is directly passed to `err_h1("MY ERROR TEXT",
    internal_handler = my_internal_handler)`
  - `internal_handler` is not directly passed to `err_h()`, but a
    default internal handler was defined for `err_h1 <- composerr("A
    problem appeared", internal_handler = my_default_handler)`
  - no `internal_handler` and no default `internal_handler` were
    defined: In this case `stop` is used as default `internal_handler`.

For example, let `err_h1` be the following error handler

``` r
err_h1 <- composerr("There is a problem", internal_handler = warning)

err_h1("The fridge is empty.")
# Warning: There is a problem: The fridge is empty.
```

with default internal handler throwing a warning. In order to alter the
behavior of `err_h1` to printing a message instead of throwing a
warning, one can call

``` r
err_h1("I am a message.", internal_handler = message)
# There is a problem: I am a message.
```

The `internal_handler` passed to the call `err_h1()` will ultimately be
used for the processing of the error message, no matter which default
internal handlers where defined for `err_h1` or the ancestor error
handlers of `err_h1`. If the `internal_handler` argument is not passed
to call `err_h1()`, then the default internal handler defined for
`err_h1` (in this case `warning`) is used.

Setting the default internal handler when creating an error handler

``` r
err_h <- composerr(internal_handler = my_default_handler)
```

and overwriting the internal handler when calling the error handler

``` r
err_h(internal_handler = my_used_internal_handler)
```

allows a very flexible error handling mechanism.

The following **example** shows the implementation of a vector
multiplication function **with complete error handling**:

``` r
my_vec_mult <- function(x, y) {
  # create your error handlers
  err_h <- composerr("In `my_vec_mult()`")
  err_h_x <- composerr("Invalid argument `x`", err_h)
  err_h_x <- composerr("Invalid argument `y`", err_h)
  if (!is.numeric(x))
    err_h_x("Not a number.")
  if (any(is.na(x)))
    err_h_x("Has missings.", internal_handler = warning)
  if (!is.numeric(y))
    err_h_x("Not a number.")
  if (any(is.na(y)))
    err_h_x("Has missings.", internal_handler = warning)
  if (length(x) != length(y))
    err_h("Vectors `x` and `y` have different length.")
  sum(x*y, na.rm = TRUE)
}

my_vec_mult("a", 1:2)
# Error: In `my_vec_mult()`: Invalid argument `x`: Not a number.

my_vec_mult(c(1, NA), 1:2)
# Warning: In `my_vec_mult()`: Invalid argument `x`: Has missings.
# 1

my_vec_mult(1:2, "b")
# Error: In `my_vec_mult()`: Invalid argument `y`: Not a number.

my_vec_mult(1:2, c(1, NA))
# Warning: In `my_vec_mult()`: Invalid argument `y`: Has non-finite values.
# 1

my_vec_mult(1:2, 1:3)
# Error: In `my_vec_mult()`: Vectors `x` and `y` have different length.

my_vec_mult(1:2, 1:2)
# 14
```

In the next **example**, we create a function `my_sum`, which usually
throws a warning if `x` contains missing values. The function also has
an argument `suppress_warnings` that allows the warnings to be
suppressed by optionally setting the default internal handler to a
function that does nothing:

``` r
my_sum <- function(x, suppress_warnings = FALSE) {
 if (isFALSE(suppress_warnings)) {
   # set default handler to throwing a warning
   err_h <- composerr("Problem in `my_sum()`", internal_handler = warning)
 } else {
   # set default handler to doing nothing
   err_h <- composerr(internal_handler = function(...) {})
 }
 if (any(is.na(x)))
   err_h("`x` has missing values.")
 sum(x, na.rm = TRUE)
}

my_sum(c(1, 2, NA))
# 3
# Warning: Problem in `my_sum()`: `x` has missing values.

my_sum(c(1, 2, NA), suppress_warnings = TRUE)
# 3
```

In the next **example**, we create an error handler `err_h_with_log`
from another error handler `err_h`, which calls the **same** internal
error handler as for `err_h`, but first writes the created error message
to an internal error log file:

``` r
internal_error_logfile <- tempfile()
my_vecmult <- function(x, y) {
  err_h <- composerr("Error in call `my_vecmult()`")
  if (!is.numeric(x))
    err_h("Argument `x` is not numeric.")
  # forgot checking `y`
  computation_of_vecmult(x, y, err_h)
}
computation_of_vecmult <- function(x, y, err_h) {
  log_error <- function(msg)
    cat(
      paste0(msg, ": Used values: x = ", x, "; y = ", y),
      file = internal_error_logfile,
      append = TRUE,
      fill = TRUE
    )
  internal_handler_without_log <- composerr_get_internal_handler(err_h)
  err_h_with_log <- composerr(
    err_h = err_h,
    internal_handler = function(msg, ...) {
      log_error(msg)
      internal_handler_without_log(msg, ...)
    }
  )
  tryCatch(
    sum(x*y),
    error = function(e) err_h_with_log(e)
  )
}
# Caught usage error (not logged)
my_vecmult("a", 1)
# Error: Error in call `my_vecmult(): Argument `x` is not numeric.`

# Caught internal error (logged)
my_vecmult(1, "a")
# Error: Error in call `my_vecmult()`: non-numeric argument for binary operator x * y

cat(paste(readLines(internal_error_logfile), collapse = "\n"))
# Error in call `my_vecmult()`: non-numeric argument for binary operator x * y Used values: x = 1; y = a
```

### Halt error processing and flush entire error stack at once

Sometimes it is useful to halt the error processing and just collect the
error messages in an internal error stack and flush the entire stack
later on. This can be done by calling:

  - `composerr_halt(err_h)`: Halt the error processing
  - `composerr_flush(err_h)`: Flush the entire error stack at once

The following **example** shows a more advanced implementation of
`my_vec_mult2` by using a validation routine with a **complete error
handling**:

``` r
validate_numeric_vec <- function(obj, err_h) {
  obj_name <- deparse(substitute(obj))
  err_h <- composerr(paste0("Invalid argument `", obj_name, "`"), err_h)
  if (!is.numeric(obj))
    err_h("Not a number.")
  err_h <- composerr(err_h = err_h)
  composerr_halt(err_h)
  for (i in seq_along(obj)) {
    err_h_item <- composerr(text_1 = paste0("Item-", i), err_h, sep_1 = " is ")
    if (is.na(obj[i]) && !is.nan(obj[i]))
      err_h_item("NA.")
    if (is.nan(obj[i]))
      err_h_item("NaN.")
    if (is.infinite(obj[i]))
      err_h_item("infinite.")
  }
  composerr_flush(err_h)
  invisible(obj)
}
my_vec_mult2 <- function(x, y) {
  err_h <- composerr("In `my_vec_mult2()`")
  validate_numeric_vec(x, err_h)
  validate_numeric_vec(y, err_h)
  if (length(x) != length(y))
    err_h("Vectors `x` and `y` have different length.")
  sum(x*y)
}

my_vec_mult2("a", 1:4)
# Error: In `my_vec_mult2()`: Invalid argument `x`: Not a number.

my_vec_mult2(c(1, NA, NaN, Inf, 5), 1:5)
# Error: In `my_vec_mult2()`: Invalid argument `x`:
#   - Item-2 is NA.
#   - Item-3 is NaN.
#   - Item-4 is infinite.

my_vec_mult2(1:5, c(NaN, 2, 3, NA, Inf))
# Error: In `my_vec_mult2()`: Invalid argument `y`:
#   - Item-1 is NA.
#   - Item-4 is NaN.
#   - Item-5 is infinite.

my_vec_mult2(1:5, 1:4)
# Error: In `my_vec_mult2()`: Vectors `x` and `y` have different length.

my_vec_mult2(1:5, 1:5)
# 55
```

## Remark:

If you like this package, please give me a star on github:
<https://github.com/a-maldet/composerr>

## License

GPL-3
