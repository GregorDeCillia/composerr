% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/composerr.R
\name{composerr_halt}
\alias{composerr_halt}
\alias{composerr_flush}
\alias{composerr_counterr}
\title{Halting and flushing errors}
\usage{
composerr_halt(
  err_h,
  multiflush_start = NULL,
  multiflush_prefix = NULL,
  multiflush_end = NULL,
  internal_handler = NULL
)

composerr_flush(
  err_h,
  multiflush_start = NULL,
  multiflush_prefix = NULL,
  multiflush_end = NULL,
  internal_handler = NULL
)

composerr_counterr(err_h)
}
\arguments{
\item{err_h}{An existing error handling function created with \code{composerr()}.}

\item{multiflush_start}{Optional string which will be added before
a multi-line error stack section, when calling \code{composerr_flush()}.
This argument only takes effect, if \code{composerr_halt(err_h)} was called
once, then at least two times \code{err_h()} and then \code{composerr_flush(err_h)}.}

\item{multiflush_prefix}{An optional string which will be added before
each line of a multi-line error stack section, when calling \code{composerr_flush()}.
This argument only takes effect, if \code{composerr_halt(err_h)} was called
once, then at least two times \code{err_h()} and then \code{composerr_flush(err_h)}.}

\item{multiflush_end}{An optional string which will be added after
a multi-line error stack section, when calling \code{composerr_flush()}.
This argument only takes effect, if \code{composerr_halt(err_h)} was called
once, then at least two times \code{err_h()} and then \code{composerr_flush(err_h)}.}

\item{internal_handler}{Optional error handling function used
as default value for \code{internal_handler}
when calling \code{err_h(msg, internal_handler = NULL)}.
This function is passed down the error handler cascade until it
finally gets called in order to process the incrementally extended error
message (e.g. throw an error or a warning or do something else with the
created error message).
The argument \code{internal_handler} can be used, in order to change the
default behavior of the error processing to throwing a warning
(\code{internal_handler = warning}) or
some other customized behavior like
writing the error message to a text file
(\code{internal_handler = function(text) cat(text, file = FILENAME)}).}
}
\description{
The following functions allow the accumulation of multiple errors
in an internal error stack and flushing them all at once later on:
\itemize{
\item \code{composerr_halt(err_h1)}: Set the error handling function \code{err_h1} to
\strong{non-flushing mode}, which means that each time \code{err_h1(msg)} is called,
the error message (\code{msg}) gets accumulated in an internal error stack,
but no error is thrown.
\item \code{composerr_flush(err_h1)}: If the internal error stack is non-empty,
then create the full error message from the internal error stack and
throw an error.
If the internal error stack is empty, then do nothing.
\item \code{composerr_counterr(err_h1)}: Counts the number of times \code{err_h1} was
called, since \code{composerr_halt(err_h1)} was called.
}
}
\section{Cascading error handlers}{

If \code{err_h1 <- composerr(...)} was created without passing another
error handler to the optional argument \code{err_h}, then
\code{err_h1} is a newly created error handler with the following structure
\verb{err_h1 = function(msg = NULL, internal_handler = NULL, ...)}.
Similarly, if \code{err_h1 <- composerr(err_h = err_h_old, ...)} was created
by passing \code{err_h = err_h_old}, then \code{err_h1} is also
a new error handler, which also has the structure
\verb{err_h1 = function(msg = NULL, internal_handler = NULL, ...)}, but
now it was created from another error handler \code{err_h_old}.

We now consider the latter case
\code{err_h1 <- composerr(text_1, err_h_old, text_2, sep_1, sep_2, internal_handler = internal_handler_1)}.
If the error handler gets executed with the following call
\code{err_h1(msg, internal_handler = internal_handler_2, ...)},
then the following things happen:
\itemize{
\item \code{err_h1} first creates a more detailed message
\code{msg_new = text_1+sep_1+msg+sep_2+text_2} (here \code{+} stands for string concatenation.)
\item if no argument \code{internal_handler} was passed to \code{err_h1},
then \code{internal_handler} is set to the default handler
(in this example \code{internal_handler_1}) previously assigned to \code{err_h1}.
If no default handler was previously assigned to \code{err_1},
then \code{internal_handler <- NULL}.
\item \code{err_h1} calls \code{err_h_old(msg_new, internal_handler = internal_handler, ...)}.
}

Now \code{err_h_old} is called and is running through the same process.
We therefore have a \strong{cascade of repeated error handler calls}, passing
down
\itemize{
\item a successively growing error message \code{msg} (incrementally adding text parts
in front and at the end of the message).
\item the argument \code{internal_handler}, which can
either be \code{NULL} or a function used for final processing of the created
error message (throw an error or a warning or do something else).
If the passed down \code{internal_handler} argument is \code{NULL} and at some
point in the error handling cascade there is a non-null
default internal handler that was assigned to some error handler
in the error handler cascade, then this default internal handler is
passed down as \code{internal_handler} instead. Once the \code{internal_handler}
is non-null, it will remain unchanged, no matter if there were other
default handlers assigned to error handler inside the error handler
cascade.
\item additional arguments \code{...} passed to \code{err_h1} are directly passed down
the error handler cascade and get directly passed to the ultimate call
of the internal error processing function \code{internal_handler(msg_final, ...)}.
}

After cascading backwards the error handlers, we ultimately reach the
primal error handler, which was created first
(from scratch) and not from another error handler.
Let us call it \code{err_h_primal}.
This primal error handler does the following things:
\itemize{
\item As usual \code{err_h_primal} concatenates its additional text parts to the
passed in message. This gives us at last the final version of the error
message. Let us call it \code{msg_final}.
\item As usual \code{err_h_primal} checks if \code{internal_handler} is \code{NULL}.
If so, \code{internal_handler} is set to the default handler that was assigned
to \code{err_h_primal}.
\item If the \code{internal_handler} is still \code{NULL}, then \code{internal_handler} is
replaced by the \code{\link[=stop]{stop()}} function.
\item Ultimately \code{err_h_primal} calls \code{internal_handler(msg_final, ...)}.
}

The result of the final call \code{internal_handler(msg_final, ...)} is silently
returned by \code{err_h1}.
}

\section{Stacked error messages}{

Let us assume \code{composerr_halt(err_h1)} was called before calling
\code{err_h1(msg, ...)}.
In this case the error message will not be cascaded down and \code{internal_handler}
will not get called.
Instead \code{err_h1} will do the following things:
\itemize{
\item As usual \code{err_h1} will append the additional message parts:
\code{msg_new <- text_1+sep_1+msg+sep_2+text_2}
\item \code{err_h1} will add the resulting error message \code{msg_new} to an internal
error stack of \code{err_h1}.
\item \code{err_h1} will return the value \code{NULL}
}

If later on, the function
\code{composerr_flush(err_h1, internal_handler = internal_handler4, ...)} is
called, then the error handler cascade will be executed as usual, but first
the error messages stored in the error stack of \code{err_h1} will be collapsed
into a single error message and this summed up error message will be passed
down the error handler cascade as usual.
In short, the call
\code{composerr_flush(err_h1, internal_handler = internal_handler4, ...)}
will do the following things:
\itemize{
\item All error messages stored in the internal error stack of \code{err_h1} will
be concatenated into a single string by adding the strings \code{multiflush_prefix}
in front of each stack entry and then collapsing the message stack into a
single string and then
adding \code{multiflush_start} in front and \code{multiflush_end} at the end this
message string:
\code{msg_new <- multiflush_start+collapse(multiflush_prefix+stack)+multiflush_end}
\item As usual, if \code{internal_handler} is \code{NULL}, then it will be replaced by
the default internal handler assigned to \code{err_h1}.
\item \code{err_h_old(msg_new, internal_handler = internal_handler)} will be called and
the error handler cascade will continue as usual.
}

It is also possible to halt the error execution in the
\strong{middle of the error handler cascade}, by calling
\code{composerr_halt(err_h_middle)},
where \code{err_h_middle} is an error handler, that has at least one child
error handler \code{err_h1} (an error handler that was created from \code{err_h_middle}).
If \code{err_h1} or a child error handler of \code{err_h1} gets called,
then the error handling will be cascaded down as usual until it reaches
\code{err_h_middle}. There it will halted and the created message will be stacked
in the internal error message stack of \code{err_h_middle}.
Only by calling \code{composerr_flush(err_h_middle)} the
error handling cascade can be continued.

It is also possible to halt the error execution at
\strong{multiple points of the error handler cascade}. In order to cascade
the errors down till the end, each halted error handler must be flushed with
\code{composerr_flush()}.
}

\examples{
\dontrun{
##### Example-1 #####
# create general error handler
err_h1 <- composerr(text_1 = "There are problems")

# create a more precise error handler listing the problems
err_h_detail <- composerr("problem", sep_1 = "-", err_h = err_h1)

# halt `err_h_detail()` processing in order to collect
# multiple errors
composerr_halt(err_h_detail)
err_h_detail("1")
err_h_detail("2")
err_h_detail("3")
composerr_flush(err_h_detail)
# Error: There are problems:
#   - problem-1
#   - problem-2
#   - problem-3

##### Example-2 #####
# Advanced implementation of vector multiplication
# using a validation routine with **advanced error handling**:
validate_numeric_vec <- function(obj, err_h) {
  obj_name <- deparse(substitute(obj))
  err_h <- composerr(paste0("Invalid argument `", obj_name, "`"), err_h)
  if (!is.numeric(obj))
    err_h("Not a number.")
  err_h <- composerr(err_h = err_h)
  composerr_halt(err_h)
  for (i in seq_along(obj)) {
    err_h_item <- composerr(text_1 = paste0("Item-", i), err_h, sep_1 = " is ")
    if (is.na(obj[i]) && !is.nan(obj[i]))
      err_h_item("NA.")
    if (is.nan(obj[i]))
      err_h_item("NaN.")
    if (is.infinite(obj[i]))
      err_h_item("infinite.")
  }
  composerr_flush(err_h)
  invisible(obj)
}
my_vec_mult2 <- function(x, y) {
  err_h <- composerr("In `my_vec_mult2()`")
  validate_numeric_vec(x, err_h)
  validate_numeric_vec(y, err_h)
  if (length(x) != length(y))
    err_h("Vectors `x` and `y` have different length.")
  sum(x*y)
}
my_vec_mult2("a", 1:4)
# Error: In `my_vec_mult2()`: Invalid argument `x`: Not a number.
my_vec_mult2(c(1, NA, NaN, Inf, 5), 1:5)
# Error: In `my_vec_mult2()`: Invalid argument `x`:
#   - Item-2 is NA.
#   - Item-3 is NaN.
#   - Item-4 is infinite.
my_vec_mult2(1:5, c(NaN, 2, 3, NA, Inf))
# Error: In `my_vec_mult2()`: Invalid argument `y`:
#   - Item-1 is NA.
#   - Item-4 is NaN.
#   - Item-5 is infinite.
my_vec_mult2(1:5, 1:4)
# Error: In `my_vec_mult2()`: Vectors `x` and `y` have different length.
my_vec_mult2(1:5, 1:5)
55
}
}
\seealso{
\code{\link[=composerr]{composerr()}}, \code{\link[=composerr_modify]{composerr_modify()}},
\code{\link[=composerr_get_internal_handler]{composerr_get_internal_handler()}} and \code{\link[=validate_composerr]{validate_composerr()}}
}
