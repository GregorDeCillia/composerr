% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/composerr.R
\name{composerr}
\alias{composerr}
\alias{composerr_modify}
\alias{composerr_halt}
\alias{composerr_flush}
\alias{composerr_counterr}
\alias{composerr_get_internal_handler}
\alias{composerr_validate}
\title{Compose error handlers (concatenate error messages)}
\usage{
composerr(
  text_1 = NULL,
  err_h = NULL,
  text_2 = NULL,
  sep_1 = ": ",
  sep_2 = NULL,
  multiflush_start = "",
  multiflush_prefix = "\\n  - ",
  multiflush_end = "\\n",
  internal_handler = NULL
)

composerr_modify(
  err_h,
  text_1 = NULL,
  text_2 = NULL,
  sep_1 = NULL,
  sep_2 = NULL,
  multiflush_start = NULL,
  multiflush_prefix = NULL,
  multiflush_end = NULL,
  internal_handler = NULL
)

composerr_halt(
  err_h,
  multiflush_start = NULL,
  multiflush_prefix = NULL,
  multiflush_end = NULL,
  internal_handler = NULL
)

composerr_flush(
  err_h,
  multiflush_start = NULL,
  multiflush_prefix = NULL,
  multiflush_end = NULL,
  internal_handler = NULL
)

composerr_counterr(err_h)

composerr_get_internal_handler(err_h)

composerr_validate(obj, err_h, allow_null = TRUE, obj_name = NULL)
}
\arguments{
\item{text_1}{A character string, which will be appended
at the beginning of the error message. The argument \code{sep_1} will be used
as text separator.}

\item{err_h}{An existing error handling function created with \code{composerr()}.}

\item{text_2}{A character string, which will be appended
at the end of the error message. The argument \code{sep_2} will be used
as text separator.}

\item{sep_1}{A character string that is used as separator for the
concatenation of \code{text_1} at the beginning of the error message.}

\item{sep_2}{A character string that is used as separator for the
concatenation of \code{text_2} at the end of the error message.}

\item{multiflush_start}{An optional string which will be added before
a multi-line error stack section, when calling \code{composerr_flush()}.
This argument only takes effect, if \code{composerr_halt(err_h)} was called
once, then at least two times \code{err_h()} and then \code{composerr_flush(err_h)}.}

\item{multiflush_prefix}{An optional string which will be added before
each line of a multi-line error stack section, when calling \code{composerr_flush()}.
This argument only takes effect, if \code{composerr_halt(err_h)} was called
once, then at least two times \code{err_h()} and then \code{composerr_flush(err_h)}.}

\item{multiflush_end}{An optional string which will be added after
a multi-line error stack section, when calling \code{composerr_flush()}.
This argument only takes effect, if \code{composerr_halt(err_h)} was called
once, then at least two times \code{err_h()} and then \code{composerr_flush(err_h)}.}

\item{internal_handler}{An optional error handling function used
as default value for \code{internal_handler} when calling \code{err_h(msg, internal_handler)}.
This argument can be used, in order to change the default behavior of the
error handling to throwing a warning (\code{internal_handler = warning}) or
some other customized behavior instead of throwing an error, like
writing the error message to a text file
(\code{internal_handler = function(text) cat(text, FILENAME)}).}

\item{obj}{An object that should be an error handling
function created by \code{composerr()}}

\item{allow_null}{A logical flag, defining if \code{obj = NULL} should be allowed.}

\item{obj_name}{An optional string, defining the variable name of
\code{obj}. This string is used for creating a meaningful error message,
in case the validation failed. If \code{obj_name} is omitted, then \code{obj_name}
is calculated by using \strong{non-standard-evaluation} on \code{obj}.}
}
\value{
A new error handling function that has an extended error message.
}
\description{
The following functions allow an advanced error handling, including the
incremental creation of complex error messages and optional accumulation of
multiple error messages (in the following \code{...} stands for
the arguments \verb{text_*}, \verb{sep_*} or \verb{multiflush_*}):
\itemize{
\item \code{composerr(...)}: Create a new customized error handling function.
\item \code{composerr(..., err_h = err_h)}: Create a new customized error handling
function, which enhances the existing error handling function \code{err_h()}.
This can be useful in order to extend the error message parts in \code{err_h()}
by additional message parts (defined in \code{...}).
\item \code{composerr_modify(..., err_h = err_h)}:
Does not create a new error handling function, but modifies an
existing error handler (\code{err_h()}). With this function you can add new
message parts to an existing error handler or change its default behavior
(e.g. throw an error instead of a warning).
**CAUTION: This function does return a function
\item \code{composerr_halt(err_h)}: Set the error handling function \code{err_h()} to
\strong{non-flushing mode}, which means that each time \code{err_h(msg)} is called,
the error message (\code{msg}) gets accumulated in an internal error stack,
but no error is thrown.
\item \code{composerr_flush(err_h)}: If the internal error stack is non-empty, then create
the full error message from the internal error stack and throw an error.
If the internal error stack is empty, then do not throw an error.
\item \code{composerr_counterr(err_h)}: Counts the number of times \code{err_h()} was
called, since \code{composerr_halt()}.
\item \code{composerr_get_internal_handler(err_h)}: Returns the \code{internal_handler} used in
\code{err_h()}. This can be useful, when the internal processing of the
error message should be adapted (e.g. instead of writing it to a file,
you want to write it to the file \strong{and} do something else).
\item \code{composerr_validate(err_h)}: Check if the object \code{err_h} is a
\code{composerr} class object (was created with \code{composerr()}).
}
}
\details{
Further more, it is possible to change the error handling behavior to
throwing a warning (or some other customized behavior) instead of throwing
an error by calling \code{err_h(msg, handler = warning)}
}
\examples{
\dontrun{
#' ### Example-1 ###
# create new error handler `err_h()` from scratch
err_h <- composerr(text_1 = "T1", sep_1 = "_", text_2 = "T2", sep_2 = "_")

# `err_h` throws errors by default
err_h("MSG")
# Error: T1_MSG_T2

# With `internal_handler = warning` warnings are sent instead
err_h("MSG", internal_handler = warning)
# Warning: T1_MSG_T2

# create a new error handler `err_h2()` based on `err_h()`
err_h2 <- composerr(
  err_h, text_1 = "X1", sep_1 = "#", text_2 = "X2", sep_2 = "#",
  internal_handler = message
)

# Because of `internal_handler = warning`, `err_h2()` sends
# plain messages by default
err_h2("MSG")
# T1_X1#MSG#X2_T2

# The original error handler `err_h()` remained unchanged
err_h("MSG")
# Error: T1_MSG_T2

# Modify an existing error handler without creating a new one
composerr_modify(
  err_h, text_1 = "Y1", sep_1 = "-", text_2 = "Y2", sep_2 = "-",
  internal_handler = warning
)

# The old error handler `err_h()` has now a different behavior
err_h("MSG")
# Warning: T1_Y1-MSG-Y2_T2

# The error handler `err_h2()` enhances the now
# modified `err_h()` and has hence also changed
err_h2("MSG")
# T1_Y1-X1#MSG#X2-Y2_T2

### Example-2 ###
# create general error handler
err_h <- composerr(text_1 = "There are problems")

# create a more precise error handler listing the problems
err_h_detail <- composerr("problem", sep_1 = "-")

# halt `err_h_detail()` processing in order to collect
# multiple errors
composerr_halt(err_h_detail)
err_h_detail("1")
err_h_detail("2")
err_h_detail("3")
composerr_flush(err_h_detail)
# Error: There are problems:
#   - problem-1
#   - problem-2
#   - problem-3

### Example-3 ###
# Vector multiplication function with **basic error handling**:
my_vec_mult <- function(x, y) {
  # create your error handlers
  err_h <- composerr("In `my_vec_mult()`")
  err_h_x <- composerr("Invalid argument `x`", err_h)
  err_h_x <- composerr("Invalid argument `y`", err_h)
  if (!is.numeric(x))
    err_h_x("Not a number.")
  if (any(is.na(x)))
    err_h_x("Has missings.", internal_handler = warning)
  if (!is.numeric(y))
    err_h_x("Not a number.")
  if (any(is.na(y)))
    err_h_x("Has missings.", internal_handler = warning)
  if (length(x) != length(y))
    err_h("Vectors `x` and `y` have different length.")
  sum(x*y, na.rm = TRUE)
}
my_vec_mult("a", 1:2)
# Error: In `my_vec_mult()`: Invalid argument `x`: Not a number.
my_vec_mult(c(1, NA), 1:2)
# Warning: In `my_vec_mult()`: Invalid argument `x`: Has missings.
# 1
my_vec_mult(1:2, "b")
# Error: In `my_vec_mult()`: Invalid argument `y`: Not a number.
my_vec_mult(1:2, c(1, NA))
# Warning: In `my_vec_mult()`: Invalid argument `y`: Has non-finite values.
# 1
my_vec_mult(1:2, 1:3)
# Error: In `my_vec_mult()`: Vectors `x` and `y` have different length.
my_vec_mult(1:2, 1:2)
# 14

### Example-4 ###
# Advanced implementation of vector multiplication
# using a validation routine with **advanced error handling**:
validate_numeric_vec <- function(obj, err_h) {
  obj_name <- deparse(substitute(obj))
  err_h <- composerr(paste0("Invalid argument `", obj_name, "`"), err_h)
  if (!is.numeric(obj))
    err_h("Not a number.")
  err_h <- composerr(err_h = err_h)
  composerr_halt(err_h)
  for (i in seq_along(obj)) {
    err_h_item <- composerr(text_1 = paste0("Item-", i), err_h, sep_1 = " is ")
    if (is.na(obj[i]) && !is.nan(obj[i]))
      err_h_item("NA.")
    if (is.nan(obj[i]))
      err_h_item("NaN.")
    if (is.infinite(obj[i]))
      err_h_item("infinite.")
  }
  composerr_flush(err_h)
  invisible(obj)
}
my_vec_mult2 <- function(x, y) {
  err_h <- composerr("In `my_vec_mult2()`")
  validate_numeric_vec(x, err_h)
  validate_numeric_vec(y, err_h)
  if (length(x) != length(y))
    err_h("Vectors `x` and `y` have different length.")
  sum(x*y)
}
my_vec_mult2("a", 1:4)
# Error: In `my_vec_mult2()`: Invalid argument `x`: Not a number.
my_vec_mult2(c(1, NA, NaN, Inf, 5), 1:5)
# Error: In `my_vec_mult2()`: Invalid argument `x`:
#   - Item-2 is NA.
#   - Item-3 is NaN.
#   - Item-4 is infinite.
my_vec_mult2(1:5, c(NaN, 2, 3, NA, Inf))
# Error: In `my_vec_mult2()`: Invalid argument `y`:
#   - Item-1 is NA.
#   - Item-4 is NaN.
#   - Item-5 is infinite.
my_vec_mult2(1:5, 1:4)
# Error: In `my_vec_mult2()`: Vectors `x` and `y` have different length.
my_vec_mult2(1:5, 1:5)
55

### Example-5 ###
# Write errors to log file
err_h <- composerr(
  "There was a problem",
  internal_handler = function(msg) {
    cat(msg, "C:/log.txt", append = TRUE, sep = "\n")
  }
)
err_h("MSG")
}
}
