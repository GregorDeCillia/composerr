% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/composerr.R
\name{composerr}
\alias{composerr}
\alias{composerr_modify}
\alias{composerr_halt}
\alias{composerr_flush}
\alias{composerr_counterr}
\alias{composerr_get_internal_handler}
\alias{composerr_validate}
\title{Compose error handlers (concatenate error messages)}
\usage{
composerr(
  text_1 = NULL,
  err_h = NULL,
  text_2 = NULL,
  sep_1 = ": ",
  sep_2 = NULL,
  multiflush_start = "",
  multiflush_prefix = "\\n  - ",
  multiflush_end = "\\n",
  internal_handler = NULL
)

composerr_modify(
  err_h,
  text_1 = NULL,
  text_2 = NULL,
  sep_1 = NULL,
  sep_2 = NULL,
  multiflush_start = NULL,
  multiflush_prefix = NULL,
  multiflush_end = NULL,
  internal_handler = NULL
)

composerr_halt(
  err_h,
  multiflush_start = NULL,
  multiflush_prefix = NULL,
  multiflush_end = NULL,
  internal_handler = NULL
)

composerr_flush(
  err_h,
  multiflush_start = NULL,
  multiflush_prefix = NULL,
  multiflush_end = NULL,
  internal_handler = NULL
)

composerr_counterr(err_h)

composerr_get_internal_handler(err_h)

composerr_validate(obj, err_h, allow_null = TRUE, obj_name = NULL)
}
\arguments{
\item{text_1}{A character string, which will be appended
at the beginning of the error message. The argument \code{sep_1} will be used
as text separator.}

\item{err_h}{An existing error handling function created with \code{composerr()}.}

\item{text_2}{A character string, which will be appended
at the end of the error message. The argument \code{sep_2} will be used
as text separator.}

\item{sep_1}{A character string that is used as separator for the
concatenation of \code{text_1} at the beginning of the error message.}

\item{sep_2}{A character string that is used as separator for the
concatenation of \code{text_2} at the end of the error message.}

\item{multiflush_start}{An optional string which will be added before
a multi-line error stack section, when calling \code{composerr_flush()}.
This argument only takes effect, if \code{composerr_halt(err_h)} was called
once, then at least two times \code{err_h()} and then \code{composerr_flush(err_h)}.}

\item{multiflush_prefix}{An optional string which will be added before
each line of a multi-line error stack section, when calling \code{composerr_flush()}.
This argument only takes effect, if \code{composerr_halt(err_h)} was called
once, then at least two times \code{err_h()} and then \code{composerr_flush(err_h)}.}

\item{multiflush_end}{An optional string which will be added after
a multi-line error stack section, when calling \code{composerr_flush()}.
This argument only takes effect, if \code{composerr_halt(err_h)} was called
once, then at least two times \code{err_h()} and then \code{composerr_flush(err_h)}.}

\item{internal_handler}{An optional error handling function used
as default value for \code{internal_handler} when calling \code{err_h(msg, internal_handler)}.
This argument can be used, in order to change the default behavior of the
error handling to throwing a warning (\code{internal_handler = warning}) or
some other customized behavior instead of throwing an error, like
writing the error message to a text file
(\code{internal_handler = function(text) cat(text, FILENAME)}).}

\item{obj}{An object that should be an error handling
function created by \code{composerr()}}

\item{allow_null}{A logical flag, defining if \code{obj = NULL} should be allowed.}

\item{obj_name}{An optional string, defining the variable name of
\code{obj}. This string is used for creating a meaningful error message,
in case the validation failed. If \code{obj_name} is omitted, then \code{obj_name}
is calculated by using \strong{non-standard-evaluation} on \code{obj}.}
}
\value{
A new error handling function that has an extended error message.
}
\description{
The following functions allow an advanced error handling, including the
incremental creation of complex error messages and optional accumulation of
multiple error messages (in the following \code{...} stands for
the arguments \verb{text_*}, \verb{sep_*} or \verb{multiflush_*}):
\itemize{
\item \code{composerr(...)}: Create a new customized error handling function.
\item \code{composerr(..., err_h = err_h)}: Create a new customized error handling
function, which enhances the existing error handling function \code{err_h()}.
This can be useful in order to extend the error message parts in \code{err_h()}
by additional message parts (defined in \code{...}).
\item \code{composerr_modify(..., err_h = err_h)}:
Does not create a new error handling function, but modifies an
existing error handler (\code{err_h()}). With this function you can add new
message parts to an existing error handler or change its default behavior
(e.g. throw an error instead of a warning).
**CAUTION: This function does return a function
\item \code{composerr_halt(err_h)}: Set the error handling function \code{err_h()} to
\strong{non-flushing mode}, which means that each time \code{err_h(msg)} is called,
the error message (\code{msg}) gets accumulated in an internal error stack,
but no error is thrown.
\item \code{composerr_flush(err_h)}: If the internal error stack is non-empty, then create
the full error message from the internal error stack and throw an error.
If the internal error stack is empty, then do not throw an error.
\item \code{composerr_counterr(err_h)}: Counts the number of times \code{err_h()} was
called, since \code{composerr_halt()}.
\item \code{composerr_get_internal_handler(err_h)}: Returns the \code{internal_handler} used in
\code{err_h()}. This can be useful, when the internal processing of the
error message should be adapted (e.g. instead of writing it to a file,
you want to write it to the file \strong{and} do something else).
\item \code{composerr_validate(err_h)}: Check if the object \code{err_h} is a
\code{composerr} class object (was created with \code{composerr()}).
}
}
\details{
Further more, it is possible to change the error handling behavior to
throwing a warning (or some other customized behavior) instead of throwing
an error by calling \code{err_h(msg, handler = warning)}
}
\examples{
\dontrun{
# -- composerr: create new error handler form old one --
# check if variable 'obj' exists and holds value TRUE
# original error handler
err_h <- composerr("Something went wrong")
if (!exists("obj"))
  err_h("`obj` does not exist.")
# Error: Something went wrong: `obj` does not exist.
obj <- FALSE
err_h2 <- composerr("`obj` has the wrong value", err_h = err_h)
if (!obj)
  err_h2("Value is FALSE.", handler = warning)
# Warning: Something went wrong: `obj` has the wrong value: Value is FALSE.
err_h("Old handler is still the same.")
# Error: Something went wrong: Old handler is still the same.

# -- composerr: update existing error handler --
# check if variable 'obj' exists and holds value TRUE
# original error handler
err_h <- composerr("Something went wrong")
if (!exists("obj"))
  err_h("`obj` does not exist.")
# Error: Something went wrong: `obj` does not exist.
obj <- FALSE
composerr_modify("`obj` has the wrong value", err_h = err_h)
if (!obj)
  err_h("Value is FALSE.", handler = warning)
# Warning: Something went wrong: `obj` has the wrong value: Value is FALSE.

# -- accumulate multiple errors --
err_h <- composerr(text_1 = "Something went wrong", sep_2 = "", text_2 = "Try again!")
err_h1 <- composerr("Error part", err_h = err_h)
composerr_halt(err_h1)
err_h1("First error.")
err_h1("Second error.")
composerr_flush(err_h1)
# Error: Something went wrong:
#   - Error part: First error.
#   - Error part: Second error.
# Try again!
}
}
